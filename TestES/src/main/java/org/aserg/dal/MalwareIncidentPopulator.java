/**
 * 
 */
package org.aserg.dal;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import org.apache.commons.codec.digest.DigestUtils;
import org.aserg.model.MalwareIncident;
import org.aserg.model.Origin;
import org.aserg.model.VirusTotalScan;
import org.aserg.utility.EnrichmentUtility;
import org.aserg.utility.EsUtility;
import org.aserg.utility.IOFileUtility;
import org.aserg.utility.SqlUtility;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;

/**
 * 
 * The data access class contains logic for fetching Malware data from
 * relational DBs, normalizes and enriches the data, and creates
 * {@link MalwareIncident} objects that can be indexed into ElasticSearch
 *
 */
public class MalwareIncidentPopulator {

	/**
	 * The logger for this class
	 */
	private static Logger log = LoggerFactory.getLogger(MalwareIncidentPopulator.class);

	/**
	 * The function fetches Malware data from the relational database and adds
	 * it to be indexed to BulkProcessor
	 * 
	 * @param index
	 *            the ElasticSearch index where the resultant document is to be
	 *            stored
	 * @param type
	 *            the ElasticSearch type where the resultant document is to be
	 *            stored
	 */
	public static void pushMalwareIncidents(String index, String type) {

		log.info("Initiating MalwareIncident Population");
		int size = 0; // These are the number of records
		MalwareIncident malIncident = null; // To populate the Malware Objects
		// HashMap will store the Scanner and Result of a specific hash
		HashMap<String, String> vtResults = null;
		VirusTotalScan vtScan = null; // To populate the Virustotal Object in
										// the
		Origin org = null;
		// Malware incident
		int count = 1;
		String prev = null;
		String lastFetchTime = IOFileUtility.readProperty("malwareTime", IOFileUtility.STATE_PATH);
		String remotehost = null;
		String localhost = null;
		String path = "/var/dionaea/binaries/";
		log.debug("Run query to get malware count");
		ResultSet rslast = SqlUtility.getResultSet(SqlUtility.MALWARE_INCIDENT_QUERY_COUNT,
				SqlUtility.getSqliteConnection(), lastFetchTime);

		ResultSet rs = null;
		String datetime = null;
		try {
			size = rslast.getInt("total");
			// Only run query for fetching records if new records have been
			// added
			if (size > 0) {
				log.debug("Run query to fetch malware records");
				rs = SqlUtility.getResultSet(SqlUtility.MALWARE_INCIDENT_QUERY, SqlUtility.getSqliteConnection(),
						lastFetchTime);
				// Get and write new time from count query, which returns the
				// datetime of
				// the latest connection fetched
				lastFetchTime = rslast.getString("connection_datetime");
				// Loop for traversing through the MalwareIncident records
				while (rs.next()) {

					// Make sure dionaea doesn't tack on :ffff: before IP
					// addresses (Split at "f:" and get the latter part of the
					// address)
					remotehost = rs.getString("remote_host");
					remotehost = remotehost.contains(":") ? remotehost.split("f:")[1] : remotehost;
					localhost = rs.getString("local_host");
					localhost = localhost.contains(":") ? localhost.split("f:")[1] : localhost;

					// if equal to prev record
					if (rs.getString("order_id").equals(prev)) {
						log.debug("MalwareIncident same as previous, connection [{}] ", prev);
						vtResults.put(rs.getString("virustotalscan_scanner"), rs.getString("virustotalscan_result"));

					}
					// for new record
					else {
						// add prev malIncident to Bulk
						if (malIncident != null) {
							if (vtScan != null) {
								vtScan.setVTscanResults(vtResults);
								malIncident.setVtScan(vtScan);
							}
							EsUtility.pushDocument(new Gson().toJson(malIncident), index, type);
							log.debug("Added MalwareIncident to BulkProcessor, connection [{}], vtScan [{}]", prev,
									vtScan);
							vtScan = null;
						}

						vtResults = new HashMap<String, String>();
						datetime = rs.getString("connection_datetime").replace(' ', 'T');
						org = EnrichmentUtility.getOrigin(remotehost);
						org = org == null ? null : org;
						malIncident = new MalwareIncident(datetime, remotehost, rs.getInt("remote_port"),
								rs.getString("connection_protocol"), localhost, rs.getInt("local_port"),
								rs.getString("connection_transport"), org, rs.getString("download_md5_hash"),
								rs.getString("download_url"), path + rs.getString("download_md5_hash"), null, vtScan);

						// if there is a virustotal scan for malware
						if (rs.getString("virustotal_permalink") != null) {
							vtResults.put(rs.getString("virustotalscan_scanner"),
									rs.getString("virustotalscan_result"));
							vtScan = new VirusTotalScan(rs.getString("virustotal_permalink"), vtResults);
							malIncident.setVtScan(vtScan);
						}

						prev = rs.getString("order_id");

					}

					// for the last one
					if (count == size) {
						EsUtility.pushDocument(new Gson().toJson(malIncident), index, type);
						log.debug("Added MalwareIncident to BulkProcessor, connection [{}], vtScan [{}]", prev, vtScan);

					}

					count++;
				}

				log.info("Pushed [{}] new malware incidents, since last fetched at [{}]", size, lastFetchTime);
				IOFileUtility.writeProperty("malwareTime", lastFetchTime, IOFileUtility.STATE_PATH);

			}

			else {

				log.info("No new malware incidents since last fetched at [{}]", lastFetchTime);
			}

		} catch (SQLException e) {
			log.error("Error occurred while trying to traverse through ResultSet", e);
		}

		SqlUtility.closeDbInstances(SqlUtility.getSqliteConnection());
	}

	/**
	 * The function fetches SSH Malware data from the relational database and
	 * adds it to be indexed to BulkProcessor
	 * 
	 * @param index
	 *            the ElasticSearch index where the resultant document is to be
	 *            stored
	 * @param type
	 *            the ElasticSearch type where the resultant document is to be
	 *            stored
	 */
	public static void pushSSHMalwareIncidents(String index, String type) {
		log.info("Initiating SSH MalwareIncident Population");
		MalwareIncident malwareIncident = null;
		String lastFetchTime = IOFileUtility.readProperty("sshMalwareTime", IOFileUtility.STATE_PATH);
		String remotehost = null;
		String time = null;
		log.debug("Run query to fetch SSH malware records");
		ResultSet rs = SqlUtility.getResultSet(SqlUtility.SSH_MALWARE_INCIDENT_QUERY,
				SqlUtility.getMysqlConnection(IOFileUtility.readProperty("SSH_DB_NAME", IOFileUtility.ARCHIVAL_PATH),
						IOFileUtility.readProperty("SSH_PASSWORD", IOFileUtility.ARCHIVAL_PATH)),
				lastFetchTime);
		int count = 0;
		Origin origin = null;
		try {

			while (rs.next()) {

				remotehost = rs.getString("remotehost");

				origin = EnrichmentUtility.getOrigin(remotehost);
				origin = origin == null ? null : origin;

				// Calculate malware hash
				FileInputStream fis = null;
				String hash = "";
				try {
					fis = new FileInputStream(
							new File(IOFileUtility.readProperty("MALWARE_BIN_PATH", IOFileUtility.STATE_PATH)
									+ rs.getString("payload")));
					hash = DigestUtils.md5Hex(fis);
					fis.close();
					log.debug("Calculated MD5 digest [{}], for binary file [{}]", hash, rs.getString("payload"));
				} catch (FileNotFoundException fne) {
					log.error("Error occurred while trying to read malware binary [{}] for calculating hash",
							rs.getString("payload"), fne);
				}
				// In case a malware has been downloaded
				time = rs.getString("connection_datetime");
				malwareIncident = new MalwareIncident(time.replace(' ', 'T'), remotehost, 22, "sshd",
						IOFileUtility.readProperty("HOST", IOFileUtility.ARCHIVAL_PATH), 22, null, origin, hash,
						rs.getString("url"), rs.getString("payload"), rs.getString("id"), null);

				// push document to ES BulkProcessor
				EsUtility.pushDocument(new Gson().toJson(malwareIncident), index, type);
				log.debug("Added SSH MalwareIncident, id [{}] to BulkProcessor ", rs.getString("id"));

			}
		} catch (SQLException | IOException e) {
			log.error("Error occurred while trying to traverse through SSH MalwareIncident ResultSet", e);
		}
		SqlUtility.closeDbInstances(SqlUtility.mysqlConnection);
		// change time in state file only if there were any new incidents
		if (count > 0)
			IOFileUtility.writeProperty("sshMalwareTime", time, IOFileUtility.STATE_PATH);
		else {
			log.debug("No new incidents added so time remains unchanged.");
		}
		log.info("[{}] new SSH malware incidents [{}], since last fetched at [{}] ", count, lastFetchTime);
	}

	/**
	 * The function fetches Malware data from the relational database and adds
	 * it to a List to be returned
	 * 
	 * @return list of {@link MalwareIncident}
	 */
	public List<MalwareIncident> populate() {
		log.info("Initiating MalwareIncident Population");
		int size = 0; // These are the number of records
		MalwareIncident malIncident = null; // To populate the Malware Objects
		HashMap<String, String> vtr = null; // HashMap will store the Scanner
		// and Result of a specific hash
		VirusTotalScan vts = null; // To populate the Virustotal Object in the
		List<MalwareIncident> malwareIncidentList = new ArrayList<MalwareIncident>();
		Origin org = null;
		// Malware incident
		int count = 1;
		String prev = null;
		String lastFetchTime = IOFileUtility.readProperty("malwareTime", IOFileUtility.STATE_PATH);
		String remotehost = null;
		log.debug("Run query to get malware count");
		ResultSet rslast = SqlUtility.getResultSet(SqlUtility.MALWARE_INCIDENT_QUERY_COUNT,
				SqlUtility.getSqliteConnection(), lastFetchTime);
		ResultSet rs = null;
		String datetime = null;
		String localhost = null;

		try {
			size = rslast.getInt("total");
			log.debug("Number of new malware incidents [{}], since last fetched at [{}] ", size, lastFetchTime);

			if (size > 0) {
				log.debug("Run query to fetch malware records");
				rs = SqlUtility.getResultSet(SqlUtility.MALWARE_INCIDENT_QUERY, SqlUtility.getSqliteConnection(),
						lastFetchTime);
				IOFileUtility.writeProperty("malwareTime", rslast.getString("connection_datetime"),
						IOFileUtility.STATE_PATH);

				while (rs.next()) {
					if (rs.getString("remote_host").contains(":"))
						remotehost = rs.getString("remote_host").split("f:")[1];
					else
						remotehost = rs.getString("remote_host");

					if (rs.getString("local_host").contains(":"))
						localhost = rs.getString("local_host").split("f:")[1];
					else
						localhost = rs.getString("local_host");
					org = EnrichmentUtility.getOrigin(remotehost);
					org = org == null ? null : org;
					// if equal to prev record
					if (rs.getString("order_id").equals(prev)) {
						log.debug("MalwareIncident same as previous, connection [{}] ", prev);
						vtr.put(rs.getString("virustotalscan_scanner"), rs.getString("virustotalscan_result"));

					} else {
						// add prev malIncident to list, or the last one
						if (malIncident != null) {
							if (vts != null) {
								vts.setVTscanResults(vtr);
								malIncident.setVtScan(vts);
							}
							malwareIncidentList.add(malIncident);
							log.debug("Added MalwareIncident to list, connection [{}], vtScan [{}]", prev, vts);
							vts = null;
						}

						vtr = new HashMap<String, String>();
						datetime = rs.getString("connection_datetime").replace(' ', 'T');
						malIncident = new MalwareIncident(datetime, remotehost, rs.getInt("remote_port"),
								rs.getString("connection_protocol"), localhost, rs.getInt("local_port"),
								rs.getString("connection_transport"), org, rs.getString("download_md5_hash"),
								rs.getString("download_url"), rs.getString("download_url"), null, vts);

						// if there is a virustotal scan for malware
						if (rs.getString("virustotal_permalink") != null) {
							vtr.put(rs.getString("virustotalscan_scanner"), rs.getString("virustotalscan_result"));
							vts = new VirusTotalScan(rs.getString("virustotal_permalink"), vtr);
							malIncident.setVtScan(vts);
						}

						prev = rs.getString("order_id");

					}

					// for the last one
					if (count == size && !malwareIncidentList.contains(malIncident)) {
						malwareIncidentList.add(malIncident);
					}

					count++;
				}

			}
		} catch (SQLException e) {
			log.error("Error occurred while trying to traverse through ResultSet", e);
		}

		SqlUtility.closeDbInstances(SqlUtility.getSqliteConnection());
		log.info("MalwareIncident Population Successful");
		return malwareIncidentList;
	}

	/**
	 * The function fetches SSH Malware data from the relational database and
	 * adds it to a List to be returned
	 * 
	 * @return list of {@link MalwareIncident}
	 */
	public List<MalwareIncident> populateSsh() {
		log.info("Initiating SSH MalwareIncident Population");
		List<MalwareIncident> malwareIncidentList = new ArrayList<MalwareIncident>();
		MalwareIncident malwareIncident = null;
		String lastFetchTime = IOFileUtility.readProperty("sshMalwareTime", IOFileUtility.STATE_PATH);
		String remotehost = null;
		log.debug("Run query to fetch SSH malware records");
		ResultSet rs = SqlUtility.getResultSet(SqlUtility.SSH_MALWARE_INCIDENT_QUERY,
				SqlUtility.getMysqlConnection(IOFileUtility.readProperty("SSH_DB_NAME", IOFileUtility.ARCHIVAL_PATH),
						IOFileUtility.readProperty("SSH_PASSWORD", IOFileUtility.ARCHIVAL_PATH)),
				lastFetchTime);
		Origin origin = null;

		try {

			while (rs.next()) {

				remotehost = rs.getString("remotehost");

				origin = EnrichmentUtility.getOrigin(remotehost);
				origin = origin == null ? null : origin;

				// Calculate malware hash
				FileInputStream fis = null;
				String hash = "";
				try {
					fis = new FileInputStream(
							new File(IOFileUtility.readProperty("MALWARE_BIN_PATH", IOFileUtility.STATE_PATH)
									+ rs.getString("payload")));
					hash = DigestUtils.md5Hex(fis);
					fis.close();
					log.debug("Calculated MD5 digest [{}], for binary file [{}]", hash, rs.getString("payload"));
				} catch (FileNotFoundException fne) {
					log.error("Error occurred while trying to read malware binary [{}] for calculating hash",
							rs.getString("payload"), fne);
				}
				// In case a malware has been downloaded
				IOFileUtility.writeProperty("sshMalwareTime", rs.getString("connection_datetime"),
						IOFileUtility.STATE_PATH);
				malwareIncident = new MalwareIncident(rs.getString("connection_datetime").replace(' ', 'T'), remotehost,
						22, "ssh", IOFileUtility.readProperty("HOST", IOFileUtility.ARCHIVAL_PATH), 22, null, origin,
						hash, rs.getString("url"), rs.getString("payload"), rs.getString("id"), null);
				malwareIncidentList.add(malwareIncident);
				log.debug("Added SSH MalwareIncident, id [{}] to list ", rs.getString("id"));

			}
		} catch (SQLException | IOException e) {
			log.error("Error occurred while trying to traverse through SSH MalwareIncident ResultSet", e);
		}
		SqlUtility.closeDbInstances(SqlUtility.mysqlConnection);
		log.debug("Number of new SSH MalwareIncidents [{}], since last fetched at time [{}] ",
				malwareIncidentList.size(), lastFetchTime);
		log.info("SSH MalwareIncident Population Successful");
		return malwareIncidentList;
	}

}
