package org.aserg.test;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.apache.commons.codec.digest.DigestUtils;
import org.aserg.model.NetworkLayerIncident;
import org.aserg.model.Auth;
import org.aserg.model.Input;
import org.aserg.model.MalwareIncident;
import org.aserg.model.MssqlIncident;
import org.aserg.model.MysqlCommand;
import org.aserg.model.MysqlIncident;
import org.aserg.model.SipIncident;
import org.aserg.model.SshIncident;
import org.aserg.model.VirusTotalScan;
import org.aserg.model.WebIncident;
import org.aserg.model.WebRule;
import org.aserg.utility.EsUtility;
import org.elasticsearch.action.bulk.BulkRequestBuilder;

import com.maxmind.geoip.LookupService;

public class MalwareIncidentPop {
	private static final String driver = "org.sqlite.JDBC";
	private static final String url = "jdbc:sqlite:/D:/CDownloads/logsql62_2.sqlite";

	// mysql
	static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";
	static final String DB_URL = "jdbc:mysql://111.68.99.39:3306/waffle";
	// "jdbc:mysql://115.186.132.21:3307/snort";
	// "jdbc:mysql://localhost:3306/kippo";
	static final String MALWARE_BIN_PATH = "/opt/kippo/dl";
	// "jdbc:mysql://111.68.99.39:3306/waffle";
	// "jdbc:mysql://localhost:3306/kippo";

	// private static final String url =
	// "jdbc:mysql:http://203.124.40.62:3307/kippo";

	BulkRequestBuilder bulkRequest;
	private Connection con = null;
	List<MalwareIncident> list = new ArrayList<MalwareIncident>();;

	/* Init SQLite Connection */
	public void initSQLiteConnection() {
		if (con == null) {
			try {
				Class.forName(driver);
				con = DriverManager.getConnection(url);
			} catch (SQLException e) {
				e.printStackTrace();
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
			}
		}
	}

	/* Init SQL Connection */
	public void initSQLConnection() {
		if (con == null) {
			try {
				Class.forName(JDBC_DRIVER);
				// for waffle
				// con = DriverManager.getConnection(DB_URL, "root",
				// "wud1991@WUD");
				// for kippo
				con = DriverManager.getConnection(DB_URL, "root", "wud1991@WUD");

			} catch (SQLException e) {
				e.printStackTrace();
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
			}
		}
	}

	public String getCountries(String remote_host) {
		String remote_country = "";
		try {

			String dir = "D:/GeoIP.dat";
			LookupService cl = new LookupService(dir, LookupService.GEOIP_MEMORY_CACHE);
			remote_country = cl.getCountry(remote_host).getName();

		} catch (IOException e) {
			System.out.println("IO Exception");
		}
		return remote_country;
	}

	public void netData() {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(
					"select INET_NTOA(iphdr.ip_src) as remote_host, tcphdr.tcp_dport as tcp_local_port, udphdr.udp_dport as udp_local_port, 	"
							+ "event.timestamp as datetime,INET_NTOA(iphdr.ip_dst) as local_host, tcphdr.tcp_sport as tcp_remote_port,	udphdr.udp_sport as udp_remote_port, "
							+ "   icmphdr.icmp_type,event.cid,event.sid, signature.sig_name, sig_class.sig_class_name FROM event INNER JOIN iphdr on (event.cid=iphdr.cid AND event.sid=iphdr.sid) "
							+ "LEFT JOIN icmphdr on (iphdr.cid = icmphdr.cid AND iphdr.sid=icmphdr.sid) LEFT JOIN tcphdr on (iphdr.cid = tcphdr.cid AND iphdr.sid = tcphdr.sid) "
							+ "LEFT JOIN udphdr on (iphdr.cid = udphdr.cid AND iphdr.sid = udphdr.sid)  INNER JOIN signature on (event.signature = signature.sig_id) "
							+ "LEFT JOIN sig_class on (signature.sig_class_id = sig_class.sig_class_id)");
			List<NetworkLayerIncident> list = new ArrayList<NetworkLayerIncident>();
			NetworkLayerIncident i = null;
			long t = System.currentTimeMillis();
			String type = null;
			String transport = null;
			String protocol = null;
			while (rs.next()) {
				int localPort = rs.getInt("tcp_local_port") == 0 ? rs.getInt("udp_local_port")
						: rs.getInt("tcp_local_port");
				int remotePort = rs.getInt("tcp_remote_port") == 0 ? rs.getInt("udp_remote_port")
						: rs.getInt("tcp_remote_port");
						// transport = udp, if udp port is not null, OR tcp if
						// tcp port
						// is not null; else, it is null

				// in case of icmp
				if (rs.getString("icmp_type") != null) {
					type = rs.getString("icmp_type");
					transport = null;
					protocol = "icmp";
				} else {
					type = null;
					transport = rs.getInt("tcp_local_port") == 0 ? "udp" : "tcp";
					protocol = "protocol";

				}
				i = new NetworkLayerIncident(rs.getString("datetime").replace(' ', 'T'), rs.getString("local_host"),
						localPort, protocol, getCountries(rs.getString("remote_host")), remotePort, transport,
						getCountries(rs.getString("remote_host")), rs.getInt("cid"), rs.getInt("sid"),
						rs.getString("sig_name"), rs.getString("sig_class_name"), type);
				list.add(i);

			}
			rs.close();
			stmt.close();
			con.close();

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			EsUtility.pushNetworkData(list, "incidents", "network_incidents");
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void mysqlData_final() {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(
					"select cmc.remote_host, cmc.local_port, cmc.connection_protocol, cmc.connection_type, cmc.datetime,cmc.connection_transport,"
							+ " cmc.local_host,cmc.connection,cmc.remote_port,mysql_command_args.mysql_command_arg_data,mysql_command_ops.mysql_command_op_name"
							+ "	from (select connections.connection, mysql_commands.mysql_command,mysql_commands.mysql_command_cmd, "
							+ " remote_host,local_port, connection_protocol,connection_type, datetime(connection_timestamp,'unixepoch','localtime') as datetime,"
							+ " connection_transport,local_host,remote_port from mysql_commands INNER JOIN connections ON (mysql_commands.connection = connections.connection)) as cmc"
							+ " LEFT JOIN mysql_command_args ON (mysql_command_args.mysql_command = cmc.mysql_command)"
							+ " LEFT JOIN mysql_command_ops ON (mysql_command_ops.mysql_command_cmd = cmc.mysql_command_cmd) ORDER BY cmc.connection ASC");
			List<MysqlIncident> list = new ArrayList<MysqlIncident>();
			MysqlCommand c = null;
			List<MysqlCommand> cmd = null;
			String prev = null;
			long t = System.currentTimeMillis();
			MysqlIncident i = null;
			while (rs.next()) {
				c = new MysqlCommand(rs.getString("mysql_command_args.mysql_command_arg_data"),
						rs.getString("mysql_command_ops.mysql_command_op_name"));
				// in case of new connection
				if (!rs.getString("cmc.connection").equals(prev)) {
					if (i != null)
						list.add(i);
					cmd = new ArrayList<MysqlCommand>();
					i = new MysqlIncident(rs.getString("cmc.datetime").replace(' ', 'T'),
							rs.getString("cmc.local_host"), rs.getInt("cmc.local_port"),
							rs.getString("cmc.connection_protocol"), rs.getString("cmc.remote_host"),
							rs.getInt("cmc.remote_port"), rs.getString("cmc.connection_transport"),
							getCountries(rs.getString("cmc.remote_host")), null);
					prev = rs.getString("cmc.connection");
					// add mysql command
					cmd.add(c);
					i.setMysqlCommands(cmd);
				}
				// if connection same as prev, just add mysql command
				else {
					cmd.add(c);
					i.setMysqlCommands(cmd);
					// for the last one
					if (!rs.next()) {
						list.add(i);
					}

				}

			}
			rs.close();
			stmt.close();
			con.close();

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			EsUtility.pushMysqlData(list, "incidents", "mysql_incidents");
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
			System.exit(0);
		}
	}

	public void webData() {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(
					"SELECT events.event_id,a_timestamp,INET_NTOA(a_client_ip) as client_ip,a_client_port,INET_NTOA(a_server_ip) as server_ip,a_server_port,b_method,b_path, b_path_parameter,b_protocol, b_user_agent,b_referer,f_content_length,"
							+ "f_content_type, f_status,id_severity,severity.severity,message_ruleid,message_ruleMsg from events left join events_messages on events_messages.event_id=events.event_id left join rule_message on rule_message.message_ruleid=events_messages.h_message_ruleId "
							+ "left join severity on severity.id_severity=events.`h_severity` order by events.event_id asc limit 0,30");

			System.out.println("query done");
			List<WebIncident> list = new ArrayList<WebIncident>();
			WebRule rule = null;
			List<WebRule> rules = null;
			String prev = null;
			long t = System.currentTimeMillis();
			WebIncident i = null;
			while (rs.next()) {
				String remotecountry = getCountries(rs.getString("client_ip"));
				// in case of new event
				if (!rs.getString("event_id").equals(prev)) {
					if (i != null) {
						if (rules != null) {
							i.setRulesList(rules);
						}
						list.add(i);
					}
					i = new WebIncident(rs.getString("a_timestamp").replace(' ', 'T'), rs.getString("server_ip"),
							rs.getInt("a_server_port"), rs.getString("b_protocol"), rs.getString("client_ip"),
							rs.getInt("a_client_port"), "tcp", remotecountry, rs.getInt("f_content_length"),
							rs.getString("f_content_type"), rs.getString("b_method"), rs.getString("b_path_parameter"),
							rs.getString("b_referer"), null, rs.getInt("id_severity"), rs.getString("severity"),
							rs.getString("b_user_agent"));
					prev = rs.getString("event_id");
					// add webrule
					if (rs.getString("message_ruleMsg") != null) {
						rules = new ArrayList<WebRule>();
						rule = new WebRule("ruleCategory", rs.getString("message_ruleMsg"));
					}

				}
				// if event same as prev, just add webrule
				else {
					rule = new WebRule("ruleCategory", rs.getString("message_ruleMsg"));
					rules.add(rule);
				}

				// for last
				if (rs.isLast() && !list.contains(i)) {
					list.add(i);
				}

			}
			rs.close();
			stmt.close();
			con.close();

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			EsUtility.pushWebData(list, "incidents", "web_incidents");
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void mssqlData() {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(
					"select cmf.*, mssql_commands.mssql_command_status as status, mssql_commands.mssql_command_cmd as cmd from "
							+ "(select connections.connection, remote_host,local_port, connection_protocol,connection_type,datetime(connection_timestamp,'unixepoch','localtime') as datetime,"
							+ " connection_transport,local_host,remote_port, mssql_fingerprint_hostname,mssql_fingerprint_cltintname from connections "
							+ " inner join mssql_fingerprints on mssql_fingerprints.connection=connections.connection) as cmf"
							+ " left join mssql_commands on mssql_commands.connection= cmf.connection");
			List<MssqlIncident> list1 = new ArrayList<MssqlIncident>();
			long t = System.currentTimeMillis();
			MssqlIncident i;
			while (rs.next()) {
				i = new MssqlIncident(rs.getString("datetime").replace(' ', 'T'), rs.getString("local_host"),
						rs.getInt("local_port"), rs.getString("connection_protocol"), rs.getString("remote_host"),
						rs.getInt("remote_port"), rs.getString("connection_transport"),
						getCountries(rs.getString("remote_host")), rs.getString("mssql_fingerprint_cltintname"),
						rs.getString("cmd"), rs.getString("status"), rs.getString("mssql_fingerprint_hostname"));
				list1.add(i);
			}
			rs.close();
			stmt.close();
			con.close();

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			EsUtility.pushMssqlData(list1, "inc", "mssql_incidents");
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
			System.exit(0);
		}
	}

	public void sipData() {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(
					"select remote_host,local_port, connection_protocol,connection_type,datetime(connection_timestamp,'unixepoch','localtime') "
							+ "as datetime, connection_transport,local_host,remote_port, sip_commands.sip_command_method, sip_commands.sip_command_user_agent, sip_commands.sip_command_call_id "
							+ "FROM sip_commands INNER JOIN connections on (sip_commands.connection=connections.connection)");
			List<SipIncident> list = new ArrayList<SipIncident>();
			long t = System.currentTimeMillis();
			while (rs.next()) {

				String datetime = rs.getString("datetime").replace(' ', 'T');
				String remotecountry = getCountries(rs.getString("remote_host"));
				SipIncident sip = new SipIncident(datetime, rs.getString("local_host"), rs.getInt("local_port"),
						rs.getString("connection_protocol"), rs.getString("remote_host"), rs.getInt("remote_port"),
						rs.getString("connection_transport"), remotecountry, rs.getString("sip_command_call_id"),
						rs.getString("sip_command_method"), rs.getString("sip_command_user_agent"));
				list.add(sip);

			}
			rs.close();
			stmt.close();
			con.close();

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			EsUtility.pushSipData(list, "incidents", "sip_incidents");
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
			System.exit(0);
		}
	}

	// malwares from KIPPO
	public void ssh_malwareData() throws FileNotFoundException {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(
					"SELECT downloads.timestamp, downloads.outfile, sessions.id, sensors.ip as localhost, url, sessions.ip as remotehost FROM downloads "
							+ "LEFT JOIN sessions on downloads.session = sessions.id LEFT JOIN sensors on sensors.id = sessions.sensor");
			long t = System.currentTimeMillis();
			List<MalwareIncident> malList = new ArrayList<MalwareIncident>();
			while (rs.next()) {

				String remotehost = rs.getString("ip");
				String remotecountry = getCountries(remotehost);

				// Calculate malware hash
				FileInputStream fis = new FileInputStream(new File(MALWARE_BIN_PATH));
				String hash = DigestUtils.md5Hex(fis);
				fis.close();
				System.out.println("Digest:" + hash);
				// In case a malware has been downloaded
				MalwareIncident m = new MalwareIncident(rs.getString("timestamp").replace(' ', 'T'),
						rs.getString("localhost"), 22, "sshd", remotehost, 22, "tcp", remotecountry, hash,
						rs.getString("url"), rs.getString("outfile"), null, rs.getString("id"));
				malList.add(m);

			}
			rs.close();
			stmt.close();
			con.close();

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			// EsUtility.pushSshData(list, "incidents", "ssh_incidents");
			if (!malList.isEmpty()) {
				EsUtility.pushMalwareData(malList, "incidents", "malware_incidents");
			}
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	public void sshData_final() {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(
					" SELECT sessions.id, sensor, sessions.ip, sensors.ip as localhost, starttime, endtime, clients.version, auth.username, auth.password,auth.success as auth_success, "
							+ "auth.timestamp as auth_timestamp, input.input, input.success as input_success,input.timestamp as input_timestamp FROM sessions "
							+ "LEFT JOIN auth ON auth.session = sessions.id LEFT JOIN input ON input.session = sessions.id  LEFT JOIN clients ON clients.id = sessions.client "
							+ " LEFT JOIN sensors on sensors.id = sessions.sensor WHERE starttime LIKE '2015-06-03%' ORDER BY sessions.id ASC");
			SshIncident ssh = null;
			List<SshIncident> list = new ArrayList<SshIncident>();
			List<Auth> authList = null;
			Auth auth = null;
			List<Input> inputList = null;
			Input input = null;
			long t = System.currentTimeMillis();
			String prev = null;
			boolean authenticated = false;
			while (rs.next()) {

				if (rs.getString("input_timestamp") != null) {
					input = new Input(rs.getString("input"),
							Boolean.valueOf(rs.getInt("input_success") == 1 ? "true" : "false"),
							rs.getString("input_timestamp").replace(' ', 'T'));

				}
				if (rs.getString("auth_timestamp") != null) {
					auth = new Auth(rs.getString("username"), rs.getString("password"),
							Boolean.valueOf(rs.getInt("auth_success") == 1 ? "true" : "false"),
							rs.getString("auth_timestamp").replace(' ', 'T'));
				}

				if (rs.getString("id").equals(prev)) {

					// if prev auth attempt in the session was successful
					if (inputList != null) {
						inputList.add(input);
						ssh.setInputList(inputList);

					}
					if (!authenticated) {
						authList.add(auth);
						ssh.setAuthList(authList);
						authenticated = Boolean.valueOf(rs.getInt("auth_success") == 1 ? "true" : "false");
					}

				} else {

					if (ssh != null) {
						if (authList != null) {
							ssh.setAuthList(authList);
						}
						if (inputList != null) {
							ssh.setInputList(inputList);
						}
						list.add(ssh);
						authList = null;
						inputList = null;
						authenticated = false;
					}

					String stime = rs.getString("starttime").replace(' ', 'T');
					String etime = rs.getString("endtime") != null ? rs.getString("endtime").replace(' ', 'T') : null;
					String client = rs.getString("version");
					String remotehost = rs.getString("ip");
					String remotecountry = getCountries(rs.getString("ip"));
					ssh = new SshIncident(stime, rs.getString("localhost"), 22, "sshd", remotehost, 22, "tcp",
							remotecountry, null, etime, null, client, rs.getString("id"));

					// in case there are auth attempts
					if (auth != null) {
						authList = new ArrayList<Auth>();
						authList.add(auth);
						ssh.setAuthList(authList);
						authenticated = Boolean.valueOf(rs.getInt("auth_success") == 1 ? "true" : "false");
						// in case auth is successful, there may or may not be
						// an input
						if (input != null) {
							inputList = new ArrayList<Input>();
							inputList.add(input);
							ssh.setInputList(inputList);
						}
					}
				}

				if (rs.isLast() && !list.contains(ssh)) {
					list.add(ssh);
				}

				prev = rs.getString("id");
				input = null;
				auth = null;

			}
			rs.close();
			stmt.close();
			con.close();

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			EsUtility.pushSshData(list, "incidents", "ssh_incidents");
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	// Work in Progress

	public void malwareData() {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(
					"select count(connections.connection) as total from connections inner join downloads on downloads.connection=connections.connection left join virustotals on virustotals.virustotal_md5_hash=downloads.download_md5_hash"
							+ " left join virustotalscans on virustotalscans.virustotal=virustotals.virustotal");
			int size = rs.getInt("total");
			System.out.println(size);
			rs = stmt.executeQuery(
					"select downloads.download, remote_host,local_port, connection_protocol,connection_type, connection_datetime, virustotal_permalink,"
							+ " connection_transport,local_host,remote_port, download_url,download_md5_hash, virustotal_md5_hash, virustotalscan_scanner,virustotalscan_result "
							+ " from connections inner join downloads on downloads.connection=connections.connection left join virustotals on virustotals.virustotal_md5_hash=downloads.download_md5_hash"
							+ " left join virustotalscans on virustotalscans.virustotal=virustotals.virustotal order by downloads.download asc");

			MalwareIncident malIncident = null;
			HashMap<String, String> vtc = null;
			long t = System.currentTimeMillis();
			String prev = null;
			int count = 1;
			VirusTotalScan vts = null;
			rs.last();
			System.out.println(rs.getRow());
			rs.beforeFirst();
			while (rs.next()) {
				// if equal to prev record
				if (rs.getString("download").equals(prev)) {
					vtc.put(rs.getString("virustotalscan_scanner"), rs.getString("virustotalscan_result"));

				} else {
					// add prev malIncident to list, or the last one
					if (malIncident != null) {
						if (vts != null) {
							vts.setVTscanResults(vtc);
							malIncident.setVtScan(vts);
							vts = null;
						}
						list.add(malIncident);
						vts = null;
					}

					vtc = new HashMap<String, String>();
					String datetime = rs.getString("connection_datetime");
					String remotecountry = getCountries(rs.getString("remote_host"));
					malIncident = new MalwareIncident(datetime.replace(' ', 'T'), rs.getString("local_host"),
							rs.getInt("local_port"), rs.getString("connection_protocol"), rs.getString("remote_host"),
							rs.getInt("remote_port"), rs.getString("connection_transport"), remotecountry,
							rs.getString("download_md5_hash"), rs.getString("download_url"), null);
					if (rs.getString("virustotal_permalink") != null) {
						vtc.put(rs.getString("virustotalscan_scanner"), rs.getString("virustotalscan_result"));
						vts = new VirusTotalScan(rs.getString("virustotal_permalink"), vtc);
						malIncident.setVtScan(vts);
					}

					prev = rs.getString("download");

				}

				// for the last one
				if (count == size && !list.contains(malIncident)) {
					list.add(malIncident);
				}
				count++;
			}
			rs.close();
			stmt.close();
			con.close();
			System.out.println(count);

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			EsUtility.pushMalwareData(list, "incidents", "malware_incidents");
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {
		MalwareIncidentPop t = new MalwareIncidentPop();
		// t.initSQLiteConnection();
		t.initSQLConnection();

		// t.netData();
		// t.sshData_final();
		t.webData();
		// try {
		// t.ssh_malwareData();
		// } catch (FileNotFoundException e) {
		// // TODO Auto-generated catch block
		// e.printStackTrace();
		// }
		// t.webData();
		// t.mysqlData_final();
	}
}
