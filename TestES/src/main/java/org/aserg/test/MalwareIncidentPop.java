package org.aserg.test;

import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import org.aserg.model.Input;
import org.aserg.model.MalwareIncident;
import org.aserg.model.MssqlIncident;
import org.aserg.model.MysqlCommand;
import org.aserg.model.MysqlIncident;
import org.aserg.model.SipIncident;
import org.aserg.model.SshIncident;
import org.aserg.model.VirusTotalScan;
import org.aserg.utility.EsUtility;
import org.elasticsearch.action.bulk.BulkRequestBuilder;

import com.maxmind.geoip.LookupService;

public class MalwareIncidentPop {
	private static final String driver = "org.sqlite.JDBC";
	private static final String url = "jdbc:sqlite:/C:/Users/TI/Downloads/logsql62_2.sqlite";
	// private static final String url =
	// "jdbc:mysql:http://203.124.40.62:3307/kippo";

	BulkRequestBuilder bulkRequest;
	private Connection con = null;
	List<MalwareIncident> list = new ArrayList<MalwareIncident>();;

	/* Getting Connections */
	public void initConnection() {
		if (con == null) {
			try {
				Class.forName(driver);
				con = DriverManager.getConnection(url);
			} catch (SQLException e) {
				e.printStackTrace();
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
			}
		}
	}

	public String getCountries(String remote_host) {
		String remote_country = "";
		try {

			String dir = "D:/GeoIP.dat";
			LookupService cl = new LookupService(dir, LookupService.GEOIP_MEMORY_CACHE);
			remote_country = cl.getCountry(remote_host).getName();

		} catch (IOException e) {
			System.out.println("IO Exception");
		}
		return remote_country;
	}

	public void mysqlData_final() {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(
					"select cmc.remote_host, cmc.local_port, cmc.connection_protocol, cmc.connection_type, cmc.datetime,cmc.connection_transport,"
							+ " cmc.local_host,cmc.connection,cmc.remote_port,mysql_command_args.mysql_command_arg_data,mysql_command_ops.mysql_command_op_name"
							+ "	from (select connections.connection, mysql_commands.mysql_command,mysql_commands.mysql_command_cmd, "
							+ " remote_host,local_port, connection_protocol,connection_type, datetime(connection_timestamp,'unixepoch','localtime') as datetime,"
							+ " connection_transport,local_host,remote_port from mysql_commands INNER JOIN connections ON (mysql_commands.connection = connections.connection)) as cmc"
							+ " LEFT JOIN mysql_command_args ON (mysql_command_args.mysql_command = cmc.mysql_command)"
							+ " LEFT JOIN mysql_command_ops ON (mysql_command_ops.mysql_command_cmd = cmc.mysql_command_cmd) ORDER BY cmc.connection ASC");
			List<MysqlIncident> list = new ArrayList<MysqlIncident>();
			MysqlCommand c = null;
			List<MysqlCommand> cmd = null;
			String prev = null;
			long t = System.currentTimeMillis();
			MysqlIncident i = null;
			while (rs.next()) {
				c = new MysqlCommand(rs.getString("mysql_command_args.mysql_command_arg_data"),
						rs.getString("mysql_command_ops.mysql_command_op_name"));
				// in case of new connection
				if (!rs.getString("cmc.connection").equals(prev)) {
					if (i != null)
						list.add(i);
					cmd = new ArrayList<MysqlCommand>();
					i = new MysqlIncident(rs.getString("cmc.datetime").replace(' ', 'T'),
							rs.getString("cmc.local_host"), Integer.parseInt(rs.getString("cmc.local_port")),
							rs.getString("cmc.connection_protocol"), rs.getString("cmc.remote_host"),
							Integer.parseInt(rs.getString("cmc.remote_port")), rs.getString("cmc.connection_transport"),
							getCountries(rs.getString("cmc.remote_host")), null);
					prev = rs.getString("cmc.connection");
					// add mysql command
					cmd.add(c);
					i.setMysqlCommands(cmd);
				}
				// if connection same as prev, just add mysql command
				else {
					cmd.add(c);
					i.setMysqlCommands(cmd);
					// for the last one
					if (!rs.next()) {
						list.add(i);
					}

				}

			}
			rs.close();
			stmt.close();
			con.close();

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			EsUtility.pushMysqlData(list, "incidents", "mysql_incidents");
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
			System.exit(0);
		}
	}

	public void mssqlData() {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(
					"select cmf.*, mssql_commands.mssql_command_status as status, mssql_commands.mssql_command_cmd as cmd from "
							+ "(select connections.connection, remote_host,local_port, connection_protocol,connection_type,datetime(connection_timestamp,'unixepoch','localtime') as datetime,"
							+ " connection_transport,local_host,remote_port, mssql_fingerprint_hostname,mssql_fingerprint_cltintname from connections "
							+ " inner join mssql_fingerprints on mssql_fingerprints.connection=connections.connection) as cmf"
							+ " left join mssql_commands on mssql_commands.connection= cmf.connection");
			List<MssqlIncident> list1 = new ArrayList<MssqlIncident>();
			long t = System.currentTimeMillis();
			MssqlIncident i;
			// String prev = null;
			while (rs.next()) {
				i = new MssqlIncident(rs.getString("datetime").replace(' ', 'T'), rs.getString("local_host"),
						Integer.parseInt(rs.getString("local_port")), rs.getString("connection_protocol"),
						rs.getString("remote_host"), Integer.parseInt(rs.getString("remote_port")),
						rs.getString("connection_transport"), getCountries(rs.getString("remote_host")),
						rs.getString("mssql_fingerprint_cltintname"), rs.getString("cmd"), rs.getString("status"),
						rs.getString("mssql_fingerprint_hostname"));
				list1.add(i);
			}
			rs.close();
			stmt.close();
			con.close();

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			EsUtility.pushMssqlData(list1, "inc", "mssql_incidents");
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
			System.exit(0);
		}
	}

	public void sipData() {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(
					"select remote_host,local_port, connection_protocol,connection_type,datetime(connection_timestamp,'unixepoch','localtime') "
							+ "as datetime, connection_transport,local_host,remote_port, sip_commands.sip_command_method, sip_commands.sip_command_user_agent, sip_commands.sip_command_call_id "
							+ "FROM sip_commands INNER JOIN connections on (sip_commands.connection=connections.connection)");
			List<SipIncident> list = new ArrayList<SipIncident>();
			long t = System.currentTimeMillis();
			while (rs.next()) {

				String datetime = rs.getString("datetime").replace(' ', 'T');
				String remotecountry = getCountries(rs.getString("remote_host"));
				SipIncident sip = new SipIncident(datetime, rs.getString("local_host"),
						Integer.parseInt(rs.getString("local_port")), rs.getString("connection_protocol"),
						rs.getString("remote_host"), Integer.parseInt(rs.getString("remote_port")),
						rs.getString("connection_transport"), remotecountry, rs.getString("sip_command_call_id"),
						rs.getString("sip_command_method"), rs.getString("sip_command_user_agent"));
				list.add(sip);

			}
			rs.close();
			stmt.close();
			con.close();

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			EsUtility.pushSipData(list, "incidents", "sip_incidents");
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
			System.exit(0);
		}
	}

	// Work in Progress
	public void sshData() {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT endtime, downloads.outfile, clients.version, auth.password, "
					+ "auth.success, auth.timestamp, auth.username, input.input, input.success, input.timestamp FROM sessions "
					+ "LEFT JOIN auth ON auth.session = sessions.id "
					+ "LEFT JOIN input ON input.session = sessions.id "
					+ "LEFT JOIN downloads ON downloads.session = sessions.id "
					+ "LEFT JOIN clients ON clients.id = sessions.client");
			// HashMap<String, String> vtc;
			List<SshIncident> list = new ArrayList<SshIncident>();
			long t = System.currentTimeMillis();
			while (rs.next()) {
				String stime = rs.getString("starttime").replace(' ', 'T');
				String etime = rs.getString("endtime").replace(' ', 'T');
				String client = rs.getString("version");
				String remotehost = rs.getString("ip");
				// String remoteport = rs.getString("remote_port");
				String remotecountry = getCountries(rs.getString("ip"));
				// String downurl = rs.getString("download_url");
				// String hash = rs.getString("download_md5_hash");
				SshIncident ssh = new SshIncident(stime, "sensor3", 123, "sss", remotehost, 22, "tcp", remotecountry,
						null, etime, null, client);
				list.add(ssh);
//				if (rs.getString("input") != null) {
//					Input i = new Input(rs.getString("input"), Boolean.valueOf(rs.getString("success")),
//							rs.getString("timestamp"));
//				}
			}
			// System.out.println("Actual hash " + hash);
			// SshIncident ssh = s; }
			rs.close();
			stmt.close();
			con.close();

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			EsUtility.pushSshData(list, "inc", "ssh_incidents");
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
			System.exit(0);
		}
	}

	public void malwareData() {
		try {
			Statement stmt = con.createStatement();
			ResultSet rs = stmt.executeQuery(
					"select count(connections.connection) as total from connections inner join downloads on downloads.connection=connections.connection left join virustotals on virustotals.virustotal_md5_hash=downloads.download_md5_hash"
							+ " left join virustotalscans on virustotalscans.virustotal=virustotals.virustotal");
			int size = Integer.parseInt(rs.getString("total"));
			System.out.println(size);
			rs = stmt.executeQuery(
					"select downloads.download, remote_host,local_port, connection_protocol,connection_type, connection_datetime, virustotal_permalink,"
							+ " connection_transport,local_host,remote_port, download_url,download_md5_hash, virustotal_md5_hash, virustotalscan_scanner,virustotalscan_result "
							+ " from connections inner join downloads on downloads.connection=connections.connection left join virustotals on virustotals.virustotal_md5_hash=downloads.download_md5_hash"
							+ " left join virustotalscans on virustotalscans.virustotal=virustotals.virustotal order by downloads.download asc");

			MalwareIncident malIncident = null;
			HashMap<String, String> vtc = null;
			long t = System.currentTimeMillis();
			String prev = null;
			int count = 1;
			VirusTotalScan vts = null;
			while (rs.next()) {
				// if equal to prev record
				if (rs.getString("download").equals(prev)) {
					vtc.put(rs.getString("virustotalscan_scanner"), rs.getString("virustotalscan_result"));

				} else {
					// add prev malIncident to list, or the last one
					if (malIncident != null) {
						if (vts != null) {
							vts.setVTscanResults(vtc);
							malIncident.setVtScan(vts);
							vts = null;
						}
						list.add(malIncident);
						vts = null;
					}

					vtc = new HashMap<String, String>();
					String datetime = rs.getString("connection_datetime");
					String remotecountry = getCountries(rs.getString("remote_host"));
					malIncident = new MalwareIncident(datetime.replace(' ', 'T'), rs.getString("local_host"),
							Integer.parseInt(rs.getString("local_port")), rs.getString("connection_protocol"),
							rs.getString("remote_host"), Integer.parseInt(rs.getString("remote_port")),
							rs.getString("connection_transport"), remotecountry, rs.getString("download_md5_hash"),
							rs.getString("download_url"), null);
					if (rs.getString("virustotal_permalink") != null) {
						vtc.put(rs.getString("virustotalscan_scanner"), rs.getString("virustotalscan_result"));
						vts = new VirusTotalScan(rs.getString("virustotal_permalink"), vtc);
						malIncident.setVtScan(vts);
					}

					prev = rs.getString("download");

				}

				// for the last one
				if (count == size && !list.contains(malIncident)) {
					list.add(malIncident);
				}
				count++;
			}
			rs.close();
			stmt.close();
			con.close();
			System.out.println(count);

			System.out.println("Time taken to traverse the ResultSet: " + (System.currentTimeMillis() - t));
			t = System.currentTimeMillis();
			EsUtility.pushMalwareData(list, "incidents", "malware_incidents");
			System.out.println("Time taken to index:" + (System.currentTimeMillis() - t));

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) {
		MalwareIncidentPop t = new MalwareIncidentPop();
		t.initConnection();
		// t.initElasticSearchConnection();
		// t.mysqlData_final();
		t.sipData();
	}
}
